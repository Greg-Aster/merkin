---
import { Image } from 'astro:assets'
// =====================================================================
// COMPONENT IMPORTS - CLEAN AND SIMPLE
// =====================================================================
import Footer from '@components/Footer.astro'
import Navbar from '@components/Navbar.astro'
import BackToTop from '@components/control/BackToTop.astro'
import SideBar from '@components/widget/SideBar.astro'
import type { MarkdownHeading } from 'astro'
import { Icon } from 'astro-icon/components'
import ImageWrapper from '../components/misc/ImageWrapper.astro'
import TimelineController from '../components/timeline/TimelineBanner.astro'
import TOC from '../components/widget/TOC.astro'
import { siteConfig } from '@/config/config'
import Layout from './Layout.astro'
import '../styles/timeline-styles.css'
import { url } from '../utils/url-utils'

// Blog-core shared client components (relative imports)
import MobileProfileOverlay from '../components/client/MobileProfileOverlay.svelte'
import PageAnimations from '../components/client/PageAnimations.svelte'
import Profile from '../components/client/Profile.svelte'
import ScrollEffects from '../components/client/ScrollEffects.svelte'
import SidenavPanels from '../components/client/SidenavPanels.svelte'
import SpecialPageFeatures from '../components/client/SpecialPageFeatures.svelte'

import { avatarConfig } from '@/config/avatar.config'
// Profile and avatar configs for Svelte components
import { profileConfig } from '@/config/config'

// App-level banner configuration (supports both legacy and advanced contracts)
import * as bannerModule from '@/config/banner.config'

// =====================================================================
// TYPESCRIPT INTERFACES
// =====================================================================

interface Props {
  title?: string
  banner?: string
  description?: string
  lang?: string
  setOGTypeArticle?: boolean
  headings?: MarkdownHeading[]
  post?: any
  bannerLink?: string
  isPostPage?: boolean
  pageMascotContext?: string
  backgroundImage?: string | null
  // ‚≠ê NEW: OneColumn layout prop
  oneColumn?: boolean
  // ‚≠ê NEW: Custom author data prop
  customAuthorData?: {
    avatarImage?: string
    authorName?: string
    authorBio?: string
    authorLink?: string
  }
}

// =====================================================================
// PROPS DESTRUCTURING AND SETUP
// =====================================================================

const {
  title,
  banner = siteConfig.banner.src,
  description,
  lang,
  setOGTypeArticle,
  headings = [],
  post,
  bannerLink = '',
  isPostPage = false,
  backgroundImage,
  oneColumn = false, // ‚≠ê NEW: Accept oneColumn prop
  customAuthorData, // ‚≠ê NEW: Extract custom author data
} = Astro.props

const rawBannerConfig = (bannerModule as any).bannerConfig ?? {}

function createLegacyStandardBannerConfig(config: any) {
  const bannerList = Array.isArray(config.bannerList) ? config.bannerList : []
  const bannerLinks = Array.isArray(config.bannerLinks) ? config.bannerLinks : []

  const getBannerLinkFromList = (index: number): string | null => {
    if (typeof bannerLinks[index] !== 'string') return null
    const link = bannerLinks[index].trim()
    return link.length > 0 ? link : null
  }

  return {
    bannerList,
    bannerLinks,
    animation: {
      enabled: config.animation?.enabled ?? true,
      interval: config.animation?.interval ?? 5000,
      transitionDuration: config.animation?.transitionDuration ?? 1000,
      direction: config.animation?.direction ?? 'forward',
    },
    video: {
      autoplay: true,
      muted: true,
      loop: true,
      playsInLine: true,
      controls: false,
      preload: 'none',
    },
    getBannerAnimationSettings: () => ({
      enabled: config.animation?.enabled ?? true,
      interval: config.animation?.interval ?? 5000,
      transitionDuration: config.animation?.transitionDuration ?? 1000,
      direction: config.animation?.direction ?? 'forward',
    }),
    getBannerLink: getBannerLinkFromList,
    hasAnyBannerLinks: () => bannerLinks.some((link: unknown) => typeof link === 'string' && link.trim().length > 0),
    getLinkPreviewData: (url: string) => ({
      title: 'Explore More',
      description: url || 'Click to visit this page',
      icon: 'arrow-up-right-from-square',
    }),
    getIconSVG: () => '',
    getBannerItemPreviewDetails: (index: number) => {
      const item = bannerList[index]
      const link = getBannerLinkFromList(index)
      return {
        hasValidLink: !!link,
        originalHref: link || '',
        urlForDisplay: link || '',
        previewTitle: item?.alt || `Banner ${index + 1}`,
        previewDescription: 'Click to explore this banner item.',
        previewIconSVG: '',
        isVideoButton: item?.type === 'video',
      }
    },
    isVideoBannerItem: (item: any) =>
      item?.type === 'video' ||
      (typeof item?.src === 'string' && /\.(webm|mp4|mov|ogg)(\?.*)?$/i.test(item.src)),
    isImageBannerItem: (item: any) =>
      item?.type === 'image' ||
      (typeof item?.src !== 'undefined' && item?.type !== 'video'),
  }
}

function normalizeBannerConfig(config: any) {
  const standardBannerConfig =
    config.standardBannerConfig ?? createLegacyStandardBannerConfig(config)

  const spacingFromConfig = config.navbar?.spacing ?? config.navbarSpacing ?? {}
  const mobilePortraitSpacing =
    config.navbar?.mobilePortraitSpacing ??
    config.navbar?.height?.mobile ??
    '4rem'

  return {
    ...config,
    defaultBannerType: config.defaultBannerType ?? 'standard',
    defaultBannerData: config.defaultBannerData ?? {},
    standardBannerConfig,
    layout: {
      ...config.layout,
      height:
        typeof config.layout?.height === 'string'
          ? config.layout.height
          : config.layout?.height?.desktop ?? '60vh',
      maxWidth: config.layout?.maxWidth ?? 1920,
      mainContentOffset: config.layout?.mainContentOffset ?? '1.5rem',
    },
    visual: {
      objectFit: config.visual?.objectFit ?? 'cover',
      objectPosition: config.visual?.objectPosition ?? 'center',
      applyGradientOverlay: config.visual?.applyGradientOverlay ?? false,
      gradientOverlay:
        config.visual?.gradientOverlay ??
        'linear-gradient(to bottom, rgba(0,0,0,0.2), transparent)',
      borderRadius: config.visual?.borderRadius ?? '0',
    },
    fallback: {
      enabled: config.fallback?.enabled ?? true,
      type: config.fallback?.type ?? 'gradient',
      value:
        config.fallback?.value ??
        'linear-gradient(to bottom, var(--color-primary-light), var(--color-primary))',
    },
    navbar: {
      ...config.navbar,
      height:
        typeof config.navbar?.height === 'string'
          ? config.navbar.height
          : config.navbar?.height?.desktop ?? '4.5rem',
      mobilePortraitSpacing,
      spacing: {
        standard: spacingFromConfig.standard ?? '0',
        timeline: spacingFromConfig.timeline ?? '5.5rem',
        video: spacingFromConfig.video ?? '5.5rem',
        image: spacingFromConfig.image ?? '0',
        assistant: spacingFromConfig.assistant ?? spacingFromConfig.standard ?? '0',
        none: spacingFromConfig.none ?? '0',
      },
    },
    panel: {
      ...config.panel,
      top: {
        standard: config.panel?.top?.standard ?? '0',
        timeline: config.panel?.top?.timeline ?? '0',
        video: config.panel?.top?.video ?? '0',
        image: config.panel?.top?.image ?? '0',
        assistant: config.panel?.top?.assistant ?? config.panel?.top?.standard ?? '0',
        none: config.panel?.top?.none ?? '0',
      },
    },
    parallax: {
      enabled: config.parallax?.enabled ?? false,
      scrollFactor: config.parallax?.scrollFactor ?? -0.02,
      easingFactor: config.parallax?.easingFactor ?? 0.1,
    },
  }
}

const bannerConfig = normalizeBannerConfig(rawBannerConfig)

const getPanelTopPosition = (bannerType: string): string => {
  switch (bannerType) {
    case 'video':
      return bannerConfig.panel.top.video
    case 'image':
      return bannerConfig.panel.top.image
    case 'timeline':
      return bannerConfig.panel.top.timeline
    case 'assistant':
      return bannerConfig.panel.top.assistant
    case 'none':
      return bannerConfig.panel.top.none
    default:
      return bannerConfig.panel.top.standard
  }
}

const determineBannerConfiguration =
  typeof (bannerModule as any).determineBannerConfiguration === 'function'
    ? (bannerModule as any).determineBannerConfiguration
    : (postValue: any, _pageType = 'default', defaultBannerLink = '') => {
        const postData = {
          bannerLink: postValue?.data?.bannerLink || '',
          customAvatar: postValue?.data?.avatarImage || '',
          customName: postValue?.data?.authorName || '',
          customBio: postValue?.data?.authorBio || '',
          slug: postValue?.slug || '',
          wantsNoDefaultBanner: postValue?.data?.showImageOnPost === false,
        }

        const hasPostTimelineBanner =
          postValue?.data?.bannerType === 'timeline' &&
          postValue?.data?.bannerData?.category
        const hasPostVideoBanner =
          postValue?.data?.bannerType === 'video' &&
          postValue?.data?.bannerData?.videoId
        const hasPostAssistantBanner = postValue?.data?.bannerType === 'assistant'
        const hasPostImageBanner =
          !postData.wantsNoDefaultBanner &&
          !!(
            postValue?.data?.image ||
            (postValue?.data?.bannerType === 'image' &&
              postValue?.data?.bannerData?.imageUrl)
          ) &&
          !hasPostVideoBanner &&
          !hasPostTimelineBanner &&
          !hasPostAssistantBanner

        const hasPostBanner =
          hasPostVideoBanner ||
          hasPostImageBanner ||
          hasPostTimelineBanner ||
          hasPostAssistantBanner

        const defaultBannerType = bannerConfig.defaultBannerType
        const hasTimelineBanner =
          hasPostTimelineBanner || (!hasPostBanner && defaultBannerType === 'timeline')
        const hasVideoBanner =
          hasPostVideoBanner || (!hasPostBanner && defaultBannerType === 'video')
        const hasImageBanner =
          hasPostImageBanner || (!hasPostBanner && defaultBannerType === 'image')
        const hasAssistantBanner =
          hasPostAssistantBanner ||
          (!hasPostBanner && defaultBannerType === 'assistant')
        const hasStandardBanner =
          !hasPostBanner &&
          !hasTimelineBanner &&
          !hasVideoBanner &&
          !hasImageBanner &&
          !hasAssistantBanner

        const currentBannerType = hasVideoBanner
          ? 'video'
          : hasImageBanner
            ? 'image'
            : hasTimelineBanner
              ? 'timeline'
              : hasAssistantBanner
                ? 'assistant'
                : hasStandardBanner
                  ? 'standard'
                  : 'none'

        const postImage = postValue?.data?.bannerData?.imageUrl || postValue?.data?.image

        return {
          postData,
          bannerType: {
            hasTimelineBanner,
            hasVideoBanner,
            hasImageBanner,
            hasAssistantBanner,
            hasStandardBanner,
            hasPostBanner,
            isStandardPage: !hasPostBanner,
            currentBannerType,
          },
          bannerDataSources: {
            videoBannerData:
              hasVideoBanner && postValue?.data?.bannerType === 'video'
                ? postValue.data.bannerData
                : hasVideoBanner
                  ? bannerConfig.defaultBannerData
                  : null,
            imageBannerData: hasImageBanner
              ? postImage
                ? { imageUrl: postImage }
                : bannerConfig.imageBannerConfig?.data || null
              : null,
            timelineBannerData:
              hasTimelineBanner && postValue?.data?.bannerType === 'timeline'
                ? postValue.data.bannerData
                : hasTimelineBanner
                  ? bannerConfig.defaultBannerData
                  : null,
            assistantBannerData:
              hasAssistantBanner && postValue?.data?.bannerType === 'assistant'
                ? postValue.data.bannerData
                : hasAssistantBanner
                  ? bannerConfig.defaultBannerData
                  : null,
          },
          layout: {
            mainPanelTop: getPanelTopPosition(currentBannerType),
            navbarSpacing:
              bannerConfig.navbar.spacing[currentBannerType] ??
              bannerConfig.navbar.spacing.standard,
            bannerHeight: bannerConfig.layout.height,
            mainContentOffset: bannerConfig.layout.mainContentOffset,
          },
          finalBannerLink: postData.bannerLink || defaultBannerLink,
          currentBannerType,
        }
      }

const getBannerAnimationSettings =
  typeof (bannerModule as any).getBannerAnimationSettings === 'function'
    ? (bannerModule as any).getBannerAnimationSettings
    : () => bannerConfig.standardBannerConfig.getBannerAnimationSettings()

const getBannerLink =
  typeof (bannerModule as any).getBannerLink === 'function'
    ? (bannerModule as any).getBannerLink
    : (index: number) => bannerConfig.standardBannerConfig.getBannerLink(index)

const getFallbackBannerCSS =
  typeof (bannerModule as any).getFallbackBannerCSS === 'function'
    ? (bannerModule as any).getFallbackBannerCSS
    : () =>
        bannerConfig.fallback.enabled
          ? bannerConfig.fallback.value
          : ''

const getDynamicBackgroundImage =
  typeof (bannerModule as any).getDynamicBackgroundImage === 'function'
    ? (bannerModule as any).getDynamicBackgroundImage
    : (bgImage?: string | null) => {
        if (bgImage === 'none' || bgImage === '') return null
        if (bgImage) return bgImage
        if (siteConfig?.banner?.enable && siteConfig?.banner?.src) {
          return siteConfig.banner.src
        }
        return null
      }

const getShouldShowParallaxBackground =
  typeof (bannerModule as any).getShouldShowParallaxBackground === 'function'
    ? (bannerModule as any).getShouldShowParallaxBackground
    : (bgImage?: string | null) =>
        !!(getDynamicBackgroundImage(bgImage) && bannerConfig.parallax.enabled)

// =====================================================================
// ‚≠ê NEW: Determine oneColumn mode from props or post data
// =====================================================================
const oneColumnMode = oneColumn || post?.data?.oneColumn || false
if (import.meta.env.DEV) {
}

// =====================================================================
// ‚≠ê RESTORED: Use working banner configuration system
// =====================================================================

// Get current path for page type determination
const currentPath = Astro.url.pathname

// ‚≠ê RESTORED: Use the working banner configuration function
const bannerConfiguration = determineBannerConfiguration(
  post,
  'default',
  bannerLink,
)

const bannerAnimationSettings = getBannerAnimationSettings()

// Destructure the processed configuration - WORKING STRUCTURE
const {
  postData,
  bannerType,
  bannerDataSources,
  layout,
  finalBannerLink,
  currentBannerType,
} = bannerConfiguration

// ‚≠ê NEW: Process custom author data - merge with existing postData
const processedAuthorData = {
  slug: postData?.slug || '',
  customAvatar: customAuthorData?.avatarImage || postData?.customAvatar || '',
  customName: customAuthorData?.authorName || postData?.customName || '',
  customBio: customAuthorData?.authorBio || postData?.customBio || '',
  customLink: customAuthorData?.authorLink || '', // ‚≠ê NEW: Custom link support
}

if (import.meta.env.DEV) {
}

// Destructure banner type flags
const {
  hasTimelineBanner,
  hasVideoBanner,
  hasImageBanner,
  hasAssistantBanner,
  hasStandardBanner,
  hasPostBanner,
  isStandardPage,
} = bannerType

// ‚≠ê RESTORED: Use working layout values
const {
  mainPanelTop, // This controls the overlap (WORKING)
  navbarSpacing, // This controls navbar spacing (WORKING + MOBILE PORTRAIT FIX)
  bannerHeight,
  mainContentOffset,
} = layout

// =====================================================================
// ‚≠ê RESTORED: Background image logic (working)
// =====================================================================

const currentBackgroundImage = getDynamicBackgroundImage(backgroundImage)
const shouldShowParallaxBackground =
  getShouldShowParallaxBackground(backgroundImage)

// =====================================================================
// BLEEPY CONTEXT SETUP
// =====================================================================

let contextForBleepy = null
if (post && post.data) {
  contextForBleepy = {
    title: post.data.title,
    description: post.data.description,
    tags: post.data.tags,
    category: post.data.category,
    timelineEra: post.data.timelineEra,
    timelineLocation: post.data.timelineLocation,
    mascotContext: post.data.mascotContext,
  }
}

// Conditionally create the grid classes
const gridLayoutClasses = [
  "transition duration-700 w-full left-0 right-0 grid grid-cols-1 md:grid-cols-[16.5rem_auto] mx-auto gap-4 md:gap-4 px-2 md:px-4 relative",
  // Only add the 3-column definition if the TOC is enabled in the site config
  siteConfig.toc.enable ? "2xl:grid-cols-[16.5rem_auto_var(--toc-width)]" : ""
].join(" ");
---

<Layout 
  title={title} 
  banner={banner} 
  description={description} 
  lang={lang} 
  setOGTypeArticle={setOGTypeArticle}
  post={post} 
>

  <!-- =============================================================== -->
  <!-- PARALLAX BACKGROUND SECTION                                   -->
  <!-- =============================================================== -->
  {shouldShowParallaxBackground && 
    <div id="parallax-banner" class="fixed top-0 left-0 w-full h-screen z-[-1] overflow-hidden">
      <ImageWrapper 
        id="parallax-image" 
        alt="Site background image" 
        class="parallax-bg object-cover w-full h-[120vh]"
        src={currentBackgroundImage} 
        position={siteConfig.banner.position || 'center'}
      />
      {siteConfig.banner.credit?.enable && 
        <div class="absolute bottom-4 right-4 text-white/50 text-xs bg-black/30 px-2 py-1 rounded">
          {siteConfig.banner.credit.text && 
            <a href={siteConfig.banner.credit.url || '#'} class="hover:text-white/80 transition">
              {siteConfig.banner.credit.text}
            </a>
          }
        </div>
      }
      <div class="absolute inset-0 bg-gradient-to-b from-black/20 to-black/50 pointer-events-none"></div>
    </div>
  }

  <!-- =============================================================== -->
  <!-- ‚≠ê SIMPLIFIED: NAVBAR - NOW ALWAYS VISIBLE                     -->
  <!-- =============================================================== -->
  <slot slot="head" name="head"></slot>
  <div id="top-row" class="z-50 pointer-events-none relative transition-all duration-700 max-w-[var(--page-width)] px-2 md:px-4 mx-auto">
    <div id="navbar-wrapper" class="pointer-events-auto sticky top-0 transition-all duration-300">
      <Navbar></Navbar>
    </div>
  </div>

  <!-- =============================================================== -->
  <!-- ‚≠ê SIMPLIFIED: Banner container - TAILWIND ONLY               -->
  <!-- =============================================================== -->
  <div id="banner-container" 
    class={`z-10 w-full relative transition-all duration-500
      ${hasTimelineBanner ? 'has-timeline-banner' : ''}
      ${hasVideoBanner ? 'has-video-banner' : ''}
      ${hasImageBanner ? 'has-image-banner' : ''}
      ${hasAssistantBanner ? 'has-assistant-banner' : ''}
      ${hasStandardBanner ? 'has-standard-banner' : ''}`}
  >

    <!-- VIDEO BANNER -->
    {hasVideoBanner && (
      <div class="banner-container-video">
        <div class="banner-aspect-container">
          <div class="banner-content-wrapper">
            <iframe
              src={`https://www.youtube.com/embed/${hasPostBanner && post?.data?.bannerType === "video" ? post.data.bannerData.videoId : bannerDataSources.videoBannerData?.videoId}?autoplay=0&mute=0&controls=1`}
              title="YouTube video player"
              frameborder="0"
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;"
              allowfullscreen
              class="absolute top-0 left-0 w-full h-full"
            ></iframe>
          </div>
        </div>
      </div>
    )}

    <!-- ‚≠ê NEW: TIMELINE BANNER WITH MOBILE INTERACTION WRAPPER -->
    {hasTimelineBanner && (
      <div class="banner-container-timeline">
        <div class="banner-aspect-container">
          <div class="banner-content-wrapper">
            <!-- ‚≠ê NEW: Mobile interaction wrapper -->
            <div id="timeline-mobile-wrapper" class="timeline-mobile-inactive">
              <!-- ‚≠ê NEW: Mobile tap indicator -->
              <div class="timeline-mobile-indicator md:hidden">
                <div class="timeline-tap-hint">
                  <Icon name="fa6-solid:hand-pointer" class="w-6 h-6 text-white/80" />
                  <span class="text-white/80 text-sm font-medium">Tap to interact with timeline</span>
                </div>
              </div>
              
              <TimelineController
                category={hasPostBanner && post?.data?.bannerType === "timeline" ? post.data.bannerData.category : (bannerDataSources.timelineBannerData?.category || "MEGA MEAL")}
                startYear={hasPostBanner && post?.data?.bannerType === "timeline" ? post.data.bannerData.startYear : bannerDataSources.timelineBannerData?.startYear}
                endYear={hasPostBanner && post?.data?.bannerType === "timeline" ? post.data.bannerData.endYear : bannerDataSources.timelineBannerData?.endYear}
                background={hasPostBanner && post?.data?.bannerType === "timeline" ? (post.data.bannerData.background || "/posts/timeline/universe.png") : (bannerDataSources.timelineBannerData?.background || "/posts/timeline/universe.png")}
                compact={hasPostBanner && post?.data?.bannerType === "timeline" ? (post.data.bannerData.compact || false) : (bannerDataSources.timelineBannerData?.compact || false)}
                class="w-full h-full"
                asBanner={true}
                bannerHeight="100%"
              />
            </div>
          </div>
        </div>
      </div>
    )}

    <!-- IMAGE BANNER -->
    {hasImageBanner && (
      <div class="banner-container-image">
        <div class="banner-aspect-container">
          <div class="banner-content-wrapper">
            {finalBannerLink ? (
              <a 
                href={finalBannerLink} 
                aria-label="Banner Link" 
                class="group block w-full h-full"
              >
                <div class="absolute transition pointer-events-none group-hover:bg-black/30 group-active:bg-black/50 w-full h-full z-50 flex items-center justify-center">
                  <Icon
                    name="fa6-solid:link"
                    class="text-white drop-shadow-lg"
                    style="font-size: clamp(2rem, 4vw, 4rem);"
                  ></Icon>
                </div>
                <img
                  src={hasPostBanner && post?.data?.bannerType === "image" ? (post.data.bannerData?.imageUrl || post.data.image) : (bannerDataSources.imageBannerData?.imageUrl || siteConfig.banner.src)}
                  alt={hasPostBanner ? (post.data.title || "Post banner image") : (title || "Banner image")}
                  class="w-full h-full object-cover"
                />
              </a>
            ) : (
              <img
                src={hasPostBanner && post?.data?.bannerType === "image" ? (post.data.bannerData?.imageUrl || post.data.image) : (bannerDataSources.imageBannerData?.imageUrl || siteConfig.banner.src)}
                alt={hasPostBanner ? (post.data.title || "Post banner image") : (title || "Banner image")}
                class="w-full h-full object-cover"
              />
            )}
          </div>
        </div>
      </div>
    )}

    <!-- STANDARD BANNER -->
    {hasStandardBanner && (
      <div class="banner-container-standard">
        <div class="banner-aspect-container">
          <div class="banner-content-wrapper">
            <div id="standard-banner-container">
              {bannerConfig.standardBannerConfig.bannerList.length > 0 ? bannerConfig.standardBannerConfig.bannerList.map((item, index) => {
                const bannerLink = getBannerLink(index);
                const isClickable = bannerLink !== null;
                const isVideoItem = bannerConfig.standardBannerConfig.isVideoBannerItem(item);
                const isImageItem = bannerConfig.standardBannerConfig.isImageBannerItem(item);
                
                return (
                  <div 
                    class="banner-slide absolute inset-0 w-full h-full transition-opacity"
                    style={`
                      transition-duration: ${bannerConfig.standardBannerConfig.animation.transitionDuration}ms;
                      opacity: ${index === 0 ? '1' : '0'};
                    `}
                    data-banner-index={index}
                  >
                    <div
                      class="banner-link group w-full h-full relative cursor-pointer"
                      data-has-link={isClickable}
                      data-href={bannerLink}
                      aria-label={`Banner ${index + 1}${isClickable ? ' - Click to visit link' : ' - Click for information'}`}
                      role="button"
                      tabindex="0"
                    >
                      <div class="absolute inset-0 w-full h-full transition-all duration-300 opacity-0 group-hover:opacity-30 bg-black pointer-events-none z-10"></div>
                      
                      <div class="absolute inset-0 w-full h-full flex items-center justify-center transition-all duration-300 opacity-0 group-hover:opacity-100 z-20 pointer-events-none">
                        <Icon
                          name="fa6-solid:circle-info"
                          class="text-white drop-shadow-lg"
                          style="font-size: clamp(2rem, 4vw, 4rem);"
                        />
                      </div>
                      
                      {isVideoItem ? (
                        <>
                          <video
                            src={item.src}
                            autoplay={bannerConfig.standardBannerConfig.video.autoplay}
                            muted={bannerConfig.standardBannerConfig.video.muted}
                            loop={bannerConfig.standardBannerConfig.video.loop}
                            playsinline={bannerConfig.standardBannerConfig.video.playsInLine}
                            controls={bannerConfig.standardBannerConfig.video.controls}
                            preload={item.preload || bannerConfig.standardBannerConfig.video.preload}
                            class={`banner-video w-full h-full object-${bannerConfig.visual.objectFit} object-${bannerConfig.visual.objectPosition} transition-transform duration-300 group-hover:scale-105`}
                            style={`border-radius: ${bannerConfig.visual.borderRadius};`}
                            onerror="this.style.display='none'; var ne = this.nextElementSibling; if (ne) ne.style.display='block';"
                          >
                            Your browser does not support the video tag.
                          </video>
                          <Image
                            src={item.fallbackImage}
                            alt={item.alt}
                            width={bannerConfig.layout.maxWidth}
                            height={Math.round(bannerConfig.layout.maxWidth * 0.5625)}
                            class={`banner-image-fallback w-full h-full object-${bannerConfig.visual.objectFit} object-${bannerConfig.visual.objectPosition} transition-transform duration-300 group-hover:scale-105`}
                            style={`border-radius: ${bannerConfig.visual.borderRadius}; display: none;`}
                            loading="lazy"
                          />
                        </>
                      ) : isImageItem ? (
                        <Image
                          src={item.src}
                          alt={item.alt}
                          width={bannerConfig.layout.maxWidth}
                          height={Math.round(bannerConfig.layout.maxWidth * 0.5625)}
                          class={`banner-image w-full h-full object-${bannerConfig.visual.objectFit} object-${bannerConfig.visual.objectPosition} transition-transform duration-300 group-hover:scale-105`}
                          style={`border-radius: ${bannerConfig.visual.borderRadius};`}
                          loading={index === 0 ? 'eager' : 'lazy'}
                        />
                      ) : null}
                    </div>
                  </div>
                );
              }) : (
                <div class="w-full h-full rounded-lg" style={`background: ${getFallbackBannerCSS()};`}></div>
              )}
              
              {bannerConfig.visual.applyGradientOverlay && (
                <div class="absolute inset-0 w-full h-full pointer-events-none" style={`background: ${bannerConfig.visual.gradientOverlay}; border-radius: ${bannerConfig.visual.borderRadius};`}></div>
              )}
            </div>
          </div>
        </div>
      </div>
    )}
  </div>

  <!-- =============================================================== -->
  <!-- ‚≠ê SIMPLIFIED: One column mobile, two column desktop           -->
  <!-- =============================================================== -->
  <div class={`w-full z-30 pointer-events-none relative`}>
    <div id="main-panel-wrapper" class="responsive-panel-wrapper relative max-w-[var(--page-width)] mx-auto pointer-events-auto">
      <div id="main-grid" class:list={[gridLayoutClasses]} style={`margin-top: ${mainContentOffset};`}>

        <!-- Grid Item 1: SIDEBAR -->
        <div class="hidden md:block mb-4 col-span-1 md:max-w-[17.5rem] onload-animation">
          <div class="mb-4">
            <Profile client:load slug={processedAuthorData.slug} customAvatar={processedAuthorData.customAvatar} customName={processedAuthorData.customName} customBio={processedAuthorData.customBio} customLink={processedAuthorData.customLink} isHomePage={currentPath === '/'} profileConfig={profileConfig} avatarConfig={avatarConfig} />
          </div>
          <SideBar class="flex-1" headings={headings} postSlug={processedAuthorData.slug} customAvatar={processedAuthorData.customAvatar} customName={processedAuthorData.customName} customBio={processedAuthorData.customBio} pageMascotContext={Astro.props.pageMascotContext} hideProfile={true}></SideBar>
        </div>

        <!-- Grid Item 2: MAIN CONTENT -->
        <main id="main" class="transition-swup-fade col-span-1 overflow-hidden">
          <div id="main-content-wrapper" class="onload-animation">
            <slot></slot>
            <div class="footer onload-animation hidden md:block">
              <Footer></Footer>
            </div>
          </div>
        </main>

        <!-- Grid Item 3: TABLE OF CONTENTS -->
        {siteConfig.toc.enable && (
          <div id="toc-wrapper" class="hidden 2xl:block z-0">
            <div id="toc-inner-wrapper" class="sticky top-14 h-[calc(100vh_-_8rem)] overflow-y-auto hide-scrollbar" style="mask-image: none;">
              <TOC headings={headings}></TOC>
            </div>
          </div>
        )}

        <!-- Mobile-only Footer -->
        <div class="footer col-span-1 onload-animation block md:hidden 2xl:hidden">
          <div class="mb-6">
            <Profile client:load slug={processedAuthorData.slug} customAvatar={processedAuthorData.customAvatar} customName={processedAuthorData.customName} customBio={processedAuthorData.customBio} customLink={processedAuthorData.customLink} isHomePage={currentPath === '/'} profileConfig={profileConfig} avatarConfig={avatarConfig} />
          </div>
          <Footer></Footer>
        </div>
      </div>

      <BackToTop></BackToTop>
    </div>
  </div>


  <!-- =============================================================== -->
  <!-- APP MASCOT SLOT (e.g. Bleepy for MEGAMEAL)                    -->
  <!-- =============================================================== -->
  {contextForBleepy && (
    <div id="bleepy-page-context" style="display: none;" data-context={JSON.stringify(contextForBleepy)}></div>
  )}
  <slot name="mascot" />

  <!-- =============================================================== -->
  <!-- ‚≠ê NEW: CLIENT-SIDE SVELTE COMPONENTS                          -->
  <!-- =============================================================== -->
  
  <!-- Sidenav panels with settings and navigation -->
  <SidenavPanels client:load siteConfig={siteConfig} />
  
  <!-- ‚≠ê UPDATED: Mobile profile overlay with custom author data -->
  <MobileProfileOverlay 
    client:load 
    postSlug={processedAuthorData.slug}
    customAvatar={processedAuthorData.customAvatar}
    customName={processedAuthorData.customName}
    customBio={processedAuthorData.customBio}
    customLink={processedAuthorData.customLink}
    profileConfig={profileConfig}
    avatarConfig={avatarConfig}
  />
  
  <!-- ‚≠ê UPDATED: Special page features with oneColumn support -->
  <SpecialPageFeatures 
    client:load 
    currentPath={currentPath} 
    oneColumn={oneColumnMode}
  />
  
  <!-- Scroll effects and parallax -->
  <ScrollEffects client:load bannerConfig={bannerConfig} siteConfig={siteConfig} />
  
  <!-- Page load animations -->
  <PageAnimations client:load />

</Layout>

<!-- =============================================================== -->
<!-- ‚≠ê SUPER SIMPLIFIED: CSS with only essential positioning       -->
<!-- =============================================================== -->
<style define:vars={{
  'main-content-offset': mainContentOffset,
  'main-panel-top': mainPanelTop,
  'navbar-spacing': navbarSpacing,
  'mobile-navbar-spacing': bannerConfig.navbar.mobilePortraitSpacing,
}}>
  /* ‚≠ê CRITICAL: Explicit mobile touch scrolling enablement */
  html, body {
    touch-action: pan-y pan-x !important;
    overscroll-behavior: auto !important;
    -webkit-overflow-scrolling: touch !important;
  }
  
  /* ‚≠ê CRITICAL: Ensure main content areas allow scrolling on mobile */
  @media (max-width: 767px) {
    body, html, #main, #main-content-wrapper, #main-grid, #main-panel-wrapper {
      touch-action: pan-y pan-x !important;
      overscroll-behavior: auto !important;
      -webkit-overflow-scrolling: touch !important;
    }
  }
  
  /* ‚≠ê ESSENTIAL: Main grid margin */
  #main-grid {
    margin-top: var(--main-content-offset);
  }
  
  /* ‚≠ê ESSENTIAL: Main panel positioning */
  .responsive-panel-wrapper {
    top: var(--main-panel-top);
    transition: top 0.3s ease;
  }
  
  /* ‚≠ê ESSENTIAL: Banner spacing from navbar */
  #banner-container {
    margin-top: var(--navbar-spacing);
    transition: margin-top 0.3s ease;
  }
  
  /* ‚≠ê SIMPLIFIED: Mobile spacing (navbar always visible now) */
  @media (max-width: 767px) {
    #banner-container {
      margin-top: var(--mobile-navbar-spacing);
    }
  }
</style>

<!-- =============================================================== -->
<!-- ‚≠ê TOUCH EVENT DEBUG LOGGING SYSTEM                            -->
<!-- =============================================================== -->
<script is:inline define:vars={{ bannerAnimationSettings }}>
  // // ‚≠ê CRITICAL: Root cause debugging system
  // function initTouchDebugging() {
  //   console.log('üîç Touch debugging initialized');
    
  //   let touchStartY = 0;
  //   let isTouchScrolling = false;
    
  //   // üïµÔ∏è DETECTIVE MODE: Find what's blocking natural scrolling
  //   console.log('üïµÔ∏è Starting root cause investigation...');
    
  //   // Check CSS properties that might block scrolling
  //   const body = document.body;
  //   const html = document.documentElement;
    
  //   console.log('üìã Body CSS Analysis:', {
  //     overflow: getComputedStyle(body).overflow,
  //     overflowY: getComputedStyle(body).overflowY,
  //     touchAction: getComputedStyle(body).touchAction,
  //     position: getComputedStyle(body).position,
  //     height: getComputedStyle(body).height,
  //     pointerEvents: getComputedStyle(body).pointerEvents
  //   });
    
  //   console.log('üìã HTML CSS Analysis:', {
  //     overflow: getComputedStyle(html).overflow,
  //     overflowY: getComputedStyle(html).overflowY,
  //     touchAction: getComputedStyle(html).touchAction,
  //     height: getComputedStyle(html).height,
  //     pointerEvents: getComputedStyle(html).pointerEvents
  //   });
    
  //   // Test what happens when we try natural scrolling
  //   function testNaturalScrolling() {
  //     const originalScrollY = window.scrollY;
  //     console.log('üß™ Testing natural scroll from position:', originalScrollY);
      
  //     // Try programmatic scroll (this should work)
  //     window.scrollBy(0, 10);
  //     setTimeout(() => {
  //       const newScrollY = window.scrollY;
  //       console.log('üß™ Programmatic scroll result:', {
  //         from: originalScrollY,
  //         to: newScrollY,
  //         success: newScrollY !== originalScrollY
  //       });
        
  //       // Scroll back
  //       window.scrollTo(0, originalScrollY);
  //     }, 100);
  //   }
    
  //   testNaturalScrolling();
    
  //   // Force touch scrolling by manually handling touchmove
  //   document.addEventListener('touchstart', (e) => {
  //     touchStartY = e.touches[0].clientY;
  //     isTouchScrolling = false;
  //     console.log(`üì± touchstart:`, {
  //       type: e.type,
  //       touches: e.touches.length,
  //       startY: touchStartY,
  //       target: e.target.tagName + (e.target.id ? `#${e.target.id}` : '') + (e.target.className ? `.${e.target.className.split(' ')[0]}` : ''),
  //       defaultPrevented: e.defaultPrevented
  //     });
  //   }, { passive: true });
    
  //   document.addEventListener('touchmove', (e) => {
  //     const currentY = e.touches[0].clientY;
  //     const deltaY = touchStartY - currentY;
      
  //     console.log(`üì± touchmove:`, {
  //       type: e.type,
  //       deltaY: deltaY,
  //       currentScrollY: window.scrollY,
  //       target: e.target.tagName + (e.target.id ? `#${e.target.id}` : '') + (e.target.className ? `.${e.target.className.split(' ')[0]}` : ''),
  //       defaultPrevented: e.defaultPrevented
  //     });
      
      // FORCE SCROLLING: Manually scroll the window with better sensitivity
      // COMMENTED OUT FOR DEBUGGING - this was masking the real issue
      /*
      if (Math.abs(deltaY) > 2) { // Lower threshold for more responsive scrolling
        isTouchScrolling = true;
        // Multiply deltaY by 2 for more natural scrolling speed
        const scrollDelta = deltaY * 50;
        const newScrollY = Math.max(0, window.scrollY + scrollDelta);
        console.log(`üöÄ FORCING SCROLL: from ${window.scrollY} to ${newScrollY} (delta: ${scrollDelta})`);
        window.scrollTo(0, newScrollY);
        touchStartY = currentY; // Update for next delta calculation
      }
      */
      
      // Check if preventDefault was called
  //     if (e.defaultPrevented) {
  //       console.warn(`‚ö†Ô∏è touchmove was prevented! Target:`, e.target);
  //     }
  //   }, { passive: true });
    
  //   document.addEventListener('touchend', (e) => {
  //     console.log(`üì± touchend:`, {
  //       type: e.type,
  //       wasScrolling: isTouchScrolling,
  //       finalScrollY: window.scrollY,
  //       defaultPrevented: e.defaultPrevented
  //     });
  //     isTouchScrolling = false;
  //   }, { passive: true });
    
  //   // Log scroll events
  //   let scrollTimeout;
  //   document.addEventListener('scroll', (e) => {
  //     clearTimeout(scrollTimeout);
  //     scrollTimeout = setTimeout(() => {
  //       console.log('üìú Scroll event:', {
  //         target: e.target === document ? 'document' : e.target.tagName,
  //         scrollY: window.scrollY,
  //         documentHeight: document.documentElement.scrollHeight,
  //         windowHeight: window.innerHeight
  //       });
  //     }, 100);
  //   }, { passive: true });
    
  //   // Log any event listeners that might interfere
  //   const originalAddEventListener = EventTarget.prototype.addEventListener;
  //   EventTarget.prototype.addEventListener = function(type, listener, options) {
  //     if (type.includes('touch') || type === 'scroll') {
  //       console.log(`üéØ Event listener added:`, {
  //         type,
  //         target: this.constructor.name,
  //         options,
  //         passive: options?.passive
  //       });
  //     }
  //     return originalAddEventListener.call(this, type, listener, options);
  //   };
  // }
  
  // Initialize immediately
  //initTouchDebugging();
  
  // Initialize banner animation system
  document.addEventListener('DOMContentLoaded', () => {
    const standardBannerContainer = document.getElementById('standard-banner-container');
    const slides = standardBannerContainer?.querySelectorAll('.banner-slide') || [];
    const animationConfig = bannerAnimationSettings || {};
    let bannerIntervalId = null;
    let currentSlideIndex = 0;

    const showSlide = (nextIndex) => {
      if (!slides.length) return;

      slides.forEach((slide, index) => {
        const slideElement = slide;
        slideElement.style.opacity = index === nextIndex ? '1' : '0';
      });
      currentSlideIndex = nextIndex;
    };

    const startBannerAnimation = () => {
      if (!slides.length || slides.length <= 1 || !animationConfig.enabled) return;
      if (bannerIntervalId) clearInterval(bannerIntervalId);

      const interval = Number(animationConfig.interval) || 5000;
      bannerIntervalId = setInterval(() => {
        const nextIndex = (currentSlideIndex + 1) % slides.length;
        showSlide(nextIndex);
      }, interval);
    };

    const stopBannerAnimation = () => {
      if (!bannerIntervalId) return;
      clearInterval(bannerIntervalId);
      bannerIntervalId = null;
    };

    if (standardBannerContainer && slides.length > 0) {
      showSlide(0);
      startBannerAnimation();

      standardBannerContainer.addEventListener('mouseenter', stopBannerAnimation);
      standardBannerContainer.addEventListener('mouseleave', startBannerAnimation);

      standardBannerContainer.querySelectorAll('.banner-link').forEach((linkElement) => {
        const hasLink = linkElement.dataset.hasLink === 'true';
        const href = linkElement.dataset.href;
        if (!hasLink || !href) return;

        linkElement.addEventListener('click', () => {
          window.location.href = href;
        });

        linkElement.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            window.location.href = href;
          }
        });
      });

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          stopBannerAnimation();
        } else {
          startBannerAnimation();
        }
      });
    }

    // ‚≠ê NEW: Timeline mobile interaction system
    const timelineWrapper = document.getElementById('timeline-mobile-wrapper');
    if (timelineWrapper && window.innerWidth < 768) {
      let isTimelineActive = false;

      // Handle timeline wrapper click/tap
      timelineWrapper.addEventListener('click', (e) => {
        if (!isTimelineActive) {
          // First tap - activate timeline
          e.preventDefault();
          e.stopPropagation();
          isTimelineActive = true;
          timelineWrapper.classList.remove('timeline-mobile-inactive');
          timelineWrapper.classList.add('timeline-mobile-active');
          if (window.location.hostname === 'localhost') {
            console.log('Timeline activated for mobile interaction');
          }
        }
        // If already active, let the click through to timeline controls
      });

      // Reset timeline interaction when clicking outside
      document.addEventListener('click', (e) => {
        if (isTimelineActive && !timelineWrapper.contains(e.target)) {
          isTimelineActive = false;
          timelineWrapper.classList.remove('timeline-mobile-active');
          timelineWrapper.classList.add('timeline-mobile-inactive');
          if (window.location.hostname === 'localhost') {
            console.log('Timeline deactivated - clicked outside');
          }
        }
      });

      // Reset timeline when navigating (blog post selection)
      window.addEventListener('beforeunload', () => {
        isTimelineActive = false;
        timelineWrapper.classList.remove('timeline-mobile-active');
        timelineWrapper.classList.add('timeline-mobile-inactive');
      });

      // Reset on page transitions (for SPA behavior)
      document.addEventListener('astro:page-load', () => {
        isTimelineActive = false;
        const wrapper = document.getElementById('timeline-mobile-wrapper');
        if (wrapper) {
          wrapper.classList.remove('timeline-mobile-active');
          wrapper.classList.add('timeline-mobile-inactive');
        }
      });
    }
  });
</script>
